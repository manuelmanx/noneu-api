import { getCollections } from "../../services/db";
import { $UserModelCreateInterface, $UserModelInterface, $UserValidationErrorsEnum } from "./user.dto";
import crypto from "../../helpers/crypto";
import userValidator from "./user.validator";
import { $ValidationResponse } from "..";
import rnd from "../../helpers/random";

/**
 * This is the model of the user.
 * With this class you can manage the base user actions as validation, login or others.
 */
class UserModel{
    public _id?:string;
    public lastLogin?:Date;
    public isSuperUser?:boolean;
    public username?:string;
    public firstName?:string;
    public lastName?:string;
    public email?:string;
    public joinDate?:Date;
    public isActive?:boolean;
    public password?:string;
    public pwResetPin?:string;
    public emailVerified?:boolean;
    constructor(
        data:$UserModelInterface
    ){
        /** Assign data to the class items.*/
        Object.assign(this, data);
    }
}

/**
 * This wrapper will manage the user collections actions.
 */
export default class UserWrapper{
    constructor(
        /** Load the collection */
        private _collection = getCollections().user
    ){
        /** Catch the collections errors */
        if (!this._collection) {
            throw new Error ("Unable to get the collection for UserClient");
        }
    }
    /**
     * Get a single user
     * @param filter The filter query to find the single user
     * @returns the user as UserModel or null
     */
    public async find(filter:Partial<$UserModelInterface>):Promise<UserModel|null>{
        /** Find the user in the database */
        const object = await this._collection?.find(filter);
        /** If user does not exist, return error */
        if(!object) return null;
        /** Wrap the user into his class model */
        const data = new UserModel(object)
        /** return the data */
        return data;
    }
    /**
     * Get an array of users by filter query
     * @param filter the filter query to find users
     * @returns the list of users or an empty array
     */
    public async filter(filter:Partial<$UserModelInterface>):Promise<UserModel[]>{
        /** filter a list of user with given filter query */
        const object = await this._collection?.filter(filter);
        /** if the list is null, return error. */
        if(!object) return [];
        /** For each element of the list, wrap it into a user class model */
        const data = object?.map((el:any)=> new UserModel(el));
        /** return the list of class models. */
        return data;
    }
    /**
     * Create new user to the database 
     * @param data 
     * @returns 
     */
    public async create(data:$UserModelCreateInterface):Promise<UserModel|null>{
        /** Join the default data with the autogenerated default data */
        const joined:$UserModelInterface = {...data, ...{
            isActive:true, 
            isSuperUser:false, 
            lastLogin:null, 
            joinDate:new Date(), 
            emailVerified:false,
            pwResetPin:undefined,
        }};
        /** encrypt the new user password */
        if (joined.password) joined.password = await crypto().encrypt(joined.password);
        /** push the new user to the database */
        const res = await this._collection?.create(joined);
        /** wrap the user into his model class */
        const model = new UserModel(res)
        /** remove the password from the model for more security */
        delete model?.password;
        /** return the model */
        return model;
    }
    /**
     * Delete a user from database
     * @param filter the query to search user.
     * @returns the id of eliminated user or null
     */
    public async delete(filter:Partial<$UserModelInterface>):Promise<string|null>{
        return new Promise((res,rej)=>{
            /** delete the user by filter */
            this._collection?.delete(filter).then(success=>{
                /** if success return the id of deleted user */
                res(success as string)
            }).catch((e:any)=>{
                /** else set it as null */
                rej(e)
            })
        })
        
    }
    /**
     * Update the token
     * @param token
     * @param newToken 
     * @returns 
     */
     public async update(filter:Partial<$UserModelInterface>, newData:Partial<$UserModelInterface>){
        /** await for data update on db, by filter and new data model */
        const object = await this._collection?.update(filter, newData);
        /** find the updated user */
        const newObject = await this.find(filter);
        /** if user does not exist return null, else return the user */
        if(!newObject) return null;
        return newObject;
    }
    /**
     * Update user password by filter
     * @param filter filter to find the user.
     * @param password the new password
     * @returns the user with updated values
     */
     public async updatePassword(filter:any, password:string){
        /** enctypt the password */
        const encrypted = await crypto().encrypt(password);
        /** push the new password to the db inside the selected user object */
        return await this.update(filter,{password:encrypted, pwResetPin:undefined})
    }
    /**
     * This method will create a recovery pin to reset your password.
     * @param email email of the user to update password
     * @returns the new pin 
     */
    public async createRecoveryPassworPin(email:string):Promise<string>{
        /** generate a new random pin */
        const pin = rnd().generateRandomAlphanumericCode(6);
        /** encrypt the new random pin */
        const encrypted = await crypto().encrypt(pin);
        /** push to db the encrypted pin */
        const updated = await this.update({email:email}, {pwResetPin:encrypted});
        /** return response */
        return pin;
    }
    /**
     * Validate the data to create a new user.
     * This function will check if the necessary fields necessary to create a new user
     * are given or valid.
     * @param data the user data from signup request
     * @returns if the form is valid and eventually the error list.
     */
    public async $isRegisterUserByEmailFormValid(data:$UserModelCreateInterface):Promise<$ValidationResponse>{
        /** check if user already exist */
        const exists = await this.find({email:data?.email})
        /** if already exist return error */
        if (!!exists) return {valid:false, errors:["USER_ALREADY_EXISTS"]};
        /** else check if data model is valid */
        return userValidator().registerUserByEmailForm(data);
    }
    /**
     * Validate Login user form
     * @param data the user data from login request
     * @returns if the form is valid and eventually the error list.
     */
    public async $isLoginUserByEmailFormValid(data:{email:string, password:string}):Promise<$ValidationResponse>{
        const {email, password} = data
        /** Retrieve the user from database */
        const user = await this.find({email:email})
        /** If the user does not exist, return error */
        if(!user) return {valid:false, errors:[$UserValidationErrorsEnum.USER_NOT_FOUND]};
        /** Check if email has been verified */
        if(!user.emailVerified) return {valid:false, errors:[$UserValidationErrorsEnum.EMAIL_NOT_VERIFIED]};
        /** Check if the password is matching the user password */
        const passwordMatchsPassword = await crypto().compare(password, user.password||'')
        if (!passwordMatchsPassword){
            /** If not, check if password is matching the recovery pin */
            const passwordMatchsRecoveryPin = await crypto().compare(password, user.pwResetPin||'')
            /** If the password is not matching the recovery pin and the password return an error. */
            if(!passwordMatchsRecoveryPin) return {valid:false, errors:[$UserValidationErrorsEnum.PASSWORD_NOT_MATCHING]};
        }
        /** Check the syntax validity */
        const valid = userValidator().loginUserByEmailForm({email:email||'', password:password||''})
        /** If the format of form is not valid, return error */
        if(!valid.valid) return valid;
        /** Else return valid. */
        return {valid:true, errors:[]};
    }
    /**
     * Validate the change password form
     * @param data Data to check from the request body
     * @returns if the form is valid and eventually the error list.
     */
    public async $isPasswordChangeUserByEmailFormValid(data:{password:string}, uid:string):Promise<$ValidationResponse>{
        /** find the user to change password */
        const user = await this.find({_id:uid})
        /** if user does not exist, return error */
        if (!user) return {valid:false, errors:[$UserValidationErrorsEnum.USER_NOT_FOUND]}
        /** else return if request body is valid to change the password */
        return userValidator().passwordChangeUserByEmailForm(data);
    }

    /**
     * Validate the email of user to change password with
     * @param email email of the user who has forgotten the password
     * @returns if is valid or not;
     */
    public async $isPasswordRecoveryUserByEmailFormValid(email:string):Promise<$ValidationResponse>{
        /** find the user to recover password */
        const user = await this.find({email:email})
        /** if user does not exist return null */
        if (!user) return {valid:false, errors:[$UserValidationErrorsEnum.USER_NOT_FOUND]}
        /** else return if the request body is valid to recover the password */
        return userValidator().passwordRecoveryUserByEmailForm(email);
    }
}